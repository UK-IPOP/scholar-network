{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Scholar Network This package is intended for people wanting to scrape Google Scholar to build graph networks of Google Scholar authors and identify network connections as opportunities for collaboration. Homepage: GitHub Features Selenium based web scraping Poetry based dependency management Basic Graph algorithms and metrics","title":"Home"},{"location":"#welcome-to-scholar-network","text":"This package is intended for people wanting to scrape Google Scholar to build graph networks of Google Scholar authors and identify network connections as opportunities for collaboration. Homepage: GitHub","title":"Welcome to Scholar Network"},{"location":"#features","text":"Selenium based web scraping Poetry based dependency management Basic Graph algorithms and metrics","title":"Features"},{"location":"api-reference/helpers/","text":"Helpers This module contains helper functions for building the network and storing data. append_pub_data_to_json ( publication_info ) Saves publication data from get_publication_data to data/scraped.json file. Parameters: Name Type Description Default publication_info list Publication data. required Source code in scholar_network/helpers.py def append_pub_data_to_json ( publication_info : list [ dict [ str , str ]]): \"\"\"Saves publication data from [get_publication_data][src.scholar_network.scraping.get_publication_data] to data/scraped.json file. Args: publication_info (list[dict[str, str]]): Publication data. \"\"\" with open ( \"data/scraped.json\" , \"r\" , encoding = ENCODING ) as f : data = json . load ( f ) data . extend ( publication_info ) with open ( \"data/scraped.json\" , \"w\" , encoding = ENCODING ) as f : json . dump ( data , f , indent = 4 , sort_keys = True ) build_graph ( author1 = None , author2 = None ) This utility function builds the Graph for the network. Currently the default graph type that is built is undirected. If no authors are provided, then a network of all the data contained in data/scraped.json will be built. If one or two authors are provided, only their networks will be built. Parameters: Name Type Description Default author1 Optional[str] Author name. Defaults to None. None author2 Optional[str] Author name. Defaults to None. None Returns: Type Description Graph models.Graph: Network graph of authors. Source code in scholar_network/helpers.py def build_graph ( author1 : Union [ str , None ] = None , author2 : Union [ str , None ] = None ) -> models . Graph : \"\"\"This utility function builds the Graph for the network. Currently the default graph type that is built is undirected. If no authors are provided, then a network of all the data contained in `data/scraped.json` will be built. If one or two authors are provided, only their networks will be built. Args: author1 (Union[str, None], optional): Author name. Defaults to None. author2 (Union[str, None], optional): Author name. Defaults to None. Returns: models.Graph: Network graph of authors. \"\"\" # TODO: add support for journal title as attribute of edge # TODO: want weight to track number of connections on each edge # TODO: look at speed enhancements # journal = scholars[name].get(\"journal_title\").strip() publications = load_publications () graph = models . Graph () if not author1 and not author2 : # make whole graph for pub in publications : co_authors = set ([ c . strip () for c in pub . get ( \"authors\" ) . split ( \",\" )]) for first in co_authors : n1 = models . Node ( first ) graph . add_node ( n1 ) for second in co_authors : if second == first : continue n2 = models . Node ( second ) graph . add_node ( n2 ) graph . add_edge ( models . Edge ( n1 , n2 ) ) return graph else : # otherwise at least one author passed for pub in publications : co_authors = set ([ c . strip () for c in pub . get ( \"authors\" ) . split ( \",\" )]) # if author in coauthors set then add that network if author1 in co_authors or author2 in co_authors : for first in co_authors : n1 = models . Node ( first ) graph . add_node ( n1 ) for second in co_authors : if second == first : continue n2 = models . Node ( second ) graph . add_node ( n2 ) graph . add_edge ( models . Edge ( n1 , n2 ) ) return graph load_publications () Utility function to load publication data. Returns: Type Description list (list[dict[str, str]]): List of publication data. Source code in scholar_network/helpers.py def load_publications () -> list [ dict [ str , str ]]: \"\"\"Utility function to load publication data. Returns: (list[dict[str, str]]): List of publication data. \"\"\" with open ( \"data/scraped.json\" , \"r\" , encoding = ENCODING ) as f : scholars = json . load ( f ) return scholars","title":"Helpers"},{"location":"api-reference/helpers/#helpers","text":"This module contains helper functions for building the network and storing data.","title":"Helpers"},{"location":"api-reference/helpers/#src.scholar_network.helpers.append_pub_data_to_json","text":"Saves publication data from get_publication_data to data/scraped.json file. Parameters: Name Type Description Default publication_info list Publication data. required Source code in scholar_network/helpers.py def append_pub_data_to_json ( publication_info : list [ dict [ str , str ]]): \"\"\"Saves publication data from [get_publication_data][src.scholar_network.scraping.get_publication_data] to data/scraped.json file. Args: publication_info (list[dict[str, str]]): Publication data. \"\"\" with open ( \"data/scraped.json\" , \"r\" , encoding = ENCODING ) as f : data = json . load ( f ) data . extend ( publication_info ) with open ( \"data/scraped.json\" , \"w\" , encoding = ENCODING ) as f : json . dump ( data , f , indent = 4 , sort_keys = True )","title":"append_pub_data_to_json()"},{"location":"api-reference/helpers/#src.scholar_network.helpers.build_graph","text":"This utility function builds the Graph for the network. Currently the default graph type that is built is undirected. If no authors are provided, then a network of all the data contained in data/scraped.json will be built. If one or two authors are provided, only their networks will be built. Parameters: Name Type Description Default author1 Optional[str] Author name. Defaults to None. None author2 Optional[str] Author name. Defaults to None. None Returns: Type Description Graph models.Graph: Network graph of authors. Source code in scholar_network/helpers.py def build_graph ( author1 : Union [ str , None ] = None , author2 : Union [ str , None ] = None ) -> models . Graph : \"\"\"This utility function builds the Graph for the network. Currently the default graph type that is built is undirected. If no authors are provided, then a network of all the data contained in `data/scraped.json` will be built. If one or two authors are provided, only their networks will be built. Args: author1 (Union[str, None], optional): Author name. Defaults to None. author2 (Union[str, None], optional): Author name. Defaults to None. Returns: models.Graph: Network graph of authors. \"\"\" # TODO: add support for journal title as attribute of edge # TODO: want weight to track number of connections on each edge # TODO: look at speed enhancements # journal = scholars[name].get(\"journal_title\").strip() publications = load_publications () graph = models . Graph () if not author1 and not author2 : # make whole graph for pub in publications : co_authors = set ([ c . strip () for c in pub . get ( \"authors\" ) . split ( \",\" )]) for first in co_authors : n1 = models . Node ( first ) graph . add_node ( n1 ) for second in co_authors : if second == first : continue n2 = models . Node ( second ) graph . add_node ( n2 ) graph . add_edge ( models . Edge ( n1 , n2 ) ) return graph else : # otherwise at least one author passed for pub in publications : co_authors = set ([ c . strip () for c in pub . get ( \"authors\" ) . split ( \",\" )]) # if author in coauthors set then add that network if author1 in co_authors or author2 in co_authors : for first in co_authors : n1 = models . Node ( first ) graph . add_node ( n1 ) for second in co_authors : if second == first : continue n2 = models . Node ( second ) graph . add_node ( n2 ) graph . add_edge ( models . Edge ( n1 , n2 ) ) return graph","title":"build_graph()"},{"location":"api-reference/helpers/#src.scholar_network.helpers.load_publications","text":"Utility function to load publication data. Returns: Type Description list (list[dict[str, str]]): List of publication data. Source code in scholar_network/helpers.py def load_publications () -> list [ dict [ str , str ]]: \"\"\"Utility function to load publication data. Returns: (list[dict[str, str]]): List of publication data. \"\"\" with open ( \"data/scraped.json\" , \"r\" , encoding = ENCODING ) as f : scholars = json . load ( f ) return scholars","title":"load_publications()"},{"location":"api-reference/models/","text":"Models This module contains the data models for building the network graph. CustomCounter dataclass Custom counter class built to emulate Counter from std lib. This class utilizes a specific use case for this program, and uses 'reflexive tuple matching' to get synonymous pairs. Parameters: Name Type Description Default lst list[tuple[str, str]] A list of author-tuple pairs. required __post_init__ ( self , lst ) special Converts author pairs into counts of unique pairs. After initialization, converts the list of tuple pairs into keys in a dictionary and increments the value by the count of the key. Also sorts the pairs so that reflexive tuples are caught. Stores the built dictionary in self.counts . Parameters: Name Type Description Default lst list A list of author-tuple pairs. required Source code in scholar_network/models.py def __post_init__ ( self , lst : list [ tuple [ str , str ]]): \"\"\"Converts author pairs into counts of unique pairs. After initialization, converts the list of tuple pairs into keys in a dictionary and increments the value by the count of the key. Also sorts the pairs so that reflexive tuples are caught. Stores the built dictionary in `self.counts`. Parameters: lst (list[tuple[str, str]]): A list of author-tuple pairs. \"\"\" result = defaultdict ( int ) for pair in lst : # by sorting we can ensure we catch the 'reflexive tuples' sorted_pair = tuple ( sorted ( pair )) result [ sorted_pair ] += 1 self . counts = result most_common ( self , limit = None ) Sorts and returns ordered tuple pairs. Parameters: Name Type Description Default limit Optional[int] Limit to return. Defaults to None. None Returns: Type Description list list[tuple[tuple[str, str], int]]: Returns most common tuple pairs. Source code in scholar_network/models.py def most_common ( self , limit : Union [ int , None ] = None ) -> list [ tuple [ tuple [ str , str ], int ]]: \"\"\"Sorts and returns ordered tuple pairs. Args: limit (Union[int, None], optional): Limit to return. Defaults to None. Returns: list[tuple[tuple[str, str], int]]: Returns most common tuple pairs. \"\"\" ordered_keys = sorted ( self . counts , key = lambda x : self . counts [ x ], reverse = True ) ordered_result : list [ tuple [ tuple [ str , str ], int ]] = [] for item in ordered_keys : ordered_result . append (( item , self . counts [ item ])) return ordered_result [: limit ] if limit else ordered_result Digraph dataclass Directed graph class. This class utilizes Node and Edge to store graph connections. Attributes: Name Type Description edges dict[Node, list[Node]] Connections stored as a dict of src node mapped to a list of connected nodes. Repeats allowed. add_edge ( self , edge ) Adds a new edge/connection to the graph. Parameters: Name Type Description Default edge Edge Edge to add to the graph required Exceptions: Type Description ValueError Raises ValueError if either src or dest Nodes not in graph. Source code in scholar_network/models.py def add_edge ( self , edge : Edge ): \"\"\"Adds a new edge/connection to the graph. Args: edge (Edge): Edge to add to the graph Raises: ValueError: Raises ValueError if either src or dest Nodes not in graph. \"\"\" if not ( edge . src in self . edges and edge . dest in self . edges ): raise ValueError ( \"Node not in graph\" ) self . edges [ edge . src ] . append ( edge . dest ) add_node ( self , node ) Adds a new node to the graph. Parameters: Name Type Description Default node Node New Node to add. required Source code in scholar_network/models.py def add_node ( self , node : Node ): \"\"\"Adds a new node to the graph. Args: node (Node): New Node to add. \"\"\" if node not in self . edges : self . edges [ node ] = [] else : pass children ( self , node ) Get's Nodes that node is linked to. Parameters: Name Type Description Default node Node Node to extract children from. required Returns: Type Description list list[Node]: List of Nodes connected to the target node. Duplicates allowed. Source code in scholar_network/models.py def children ( self , node : Node ) -> list [ Node ]: \"\"\"Get's Nodes that `node` is linked to. Args: node (Node): Node to extract children from. Returns: list[Node]: List of Nodes connected to the target node. Duplicates allowed. \"\"\" return self . edges [ node ] edge_count ( self ) Counts all the edges in the graph. Duplicates are counted. Returns: Type Description int int: Number of edges/connections in the graph. Source code in scholar_network/models.py def edge_count ( self ) -> int : \"\"\"Counts all the edges in the graph. Duplicates are counted. Returns: int: Number of edges/connections in the graph. \"\"\" return sum ( len ( self . children ( node )) for node in self . edges ) edge_rank ( self , vertex = None , limit = None ) Ranks the edges based on their weight. Ranks are calculated either for the entire graph (default) or for the specified Node. Parameters: Name Type Description Default vertex Optional[src.scholar_network.models.Node] Node to run calculation on. Defaults to None. None limit Optional[int] Limit for the number of edges returned. Defaults to None. None Returns: Type Description list list[tuple[tuple[str, str], int]]: Returns a sorted (by weight) list of edges up to the limit parameter. Source code in scholar_network/models.py def edge_rank ( self , vertex : Union [ Node , None ] = None , limit : Union [ int , None ] = None ) -> list [ tuple [ tuple [ str , str ], int ]]: \"\"\"Ranks the edges based on their weight. Ranks are calculated either for the entire graph (default) or for the specified Node. Args: vertex (Union[Node, None], optional): Node to run calculation on. Defaults to None. limit (Union[int, None], optional): Limit for the number of edges returned. Defaults to None. Returns: list[tuple[tuple[str, str], int]]: Returns a sorted (by weight) list of edges up to the limit parameter. \"\"\" if vertex : pairs = [] for partner in self . edges [ vertex ]: pairs . append (( vertex . name , partner . name )) return ( CustomCounter ( pairs ) . most_common ( limit ) if limit else CustomCounter ( pairs ) . most_common () ) return ( CustomCounter ( self . node_pairs ()) . most_common ( limit ) if limit else CustomCounter ( self . node_pairs ()) . most_common () ) get_node ( self , name ) Gets a Node from the graph based on the Node's name attribute. Parameters: Name Type Description Default name str Name of the Node to return from the graph. required Exceptions: Type Description NameError If no matching Node can be found. Returns: Type Description Node Node: The Node matching the search name. Source code in scholar_network/models.py def get_node ( self , name : str ) -> Node : \"\"\"Gets a Node from the graph based on the Node's name attribute. Args: name (str): Name of the Node to return from the graph. Raises: NameError: If no matching Node can be found. Returns: Node: The Node matching the search name. \"\"\" for n in self . edges : if n . name == name : return n raise NameError ( name ) has_node ( self , node ) Checks if the graph contains a given Node. Parameters: Name Type Description Default node Node Node to search the graph for. required Returns: Type Description bool bool: True if the node exists, otherwise False. Source code in scholar_network/models.py def has_node ( self , node : Node ) -> bool : \"\"\"Checks if the graph contains a given Node. Args: node (Node): Node to search the graph for. Returns: bool: True if the node exists, otherwise False. \"\"\" return node in self . edges node_pairs ( self ) Generates pairs of nodes representing edge connections. Duplicates allowed. Returns: Type Description list list[tuple[str, str]]: List of node pairs. Source code in scholar_network/models.py def node_pairs ( self ) -> list [ tuple [ str , str ]]: \"\"\"Generates pairs of nodes representing edge connections. Duplicates allowed. Returns: list[tuple[str, str]]: List of node pairs. \"\"\" pairs = [] for src in self . edges : for dest in self . edges [ src ]: pairs . append (( src . name , dest . name )) return pairs vertex_count ( self ) Counts the total number of Nodes in the graph. Returns: Type Description int int: Number of Nodes in the graph. Source code in scholar_network/models.py def vertex_count ( self ) -> int : \"\"\"Counts the total number of Nodes in the graph. Returns: int: Number of Nodes in the graph. \"\"\" return len ( self . edges ) vertex_degree ( self , vertex = None ) Calculates the number of Nodes connected to the target vertex. If no target vertex provided, calculates connected Nodes for each Node in the graph. Parameters: Name Type Description Default vertex Optional[src.scholar_network.models.Node] Target vertex to search for. Defaults to None. None Returns: Type Description Union[int, list[int]] Union[int, list[int]]: Either the degree of the target vertex or a list of the degrees of all the nodes. Source code in scholar_network/models.py def vertex_degree ( self , vertex : Union [ Node , None ] = None ) -> Union [ int , list [ int ]]: \"\"\"Calculates the number of Nodes connected to the target vertex. If no target vertex provided, calculates connected Nodes for each Node in the graph. Args: vertex (Union[Node, None], optional): Target vertex to search for. Defaults to None. Returns: Union[int, list[int]]: Either the degree of the target vertex or a list of the degrees of all the nodes. \"\"\" if vertex : return len ( self . children ( vertex )) return sorted ([ len ( self . children ( n )) for n in self . edges ]) Edge dataclass Edge connects Nodes that co-occur together in the same publication. Edges are directed in a DiGraph and undirected in Graph. ^^ Both of these cases are handled by the (Di)Graph classes not the Edge itself. Attributes: Name Type Description src Node Source node for the connection. dest Node Destination node for the connection. __str__ ( self ) special Makes the string representation an of the edge connection. Returns: Type Description str str: Connection being represented by the edge in string form. Source code in scholar_network/models.py def __str__ ( self ) -> str : \"\"\"Makes the string representation an of the edge connection. Returns: str: Connection being represented by the edge in string form. \"\"\" return f \" { self . src } -> { self . dest } \" Graph dataclass Undirected sub-class of the Digraph. add_edge ( self , edge ) Adds both (directed) edges to the graph. Source code in scholar_network/models.py def add_edge ( self , edge : Edge ): \"\"\"Adds both (directed) edges to the graph.\"\"\" Digraph . add_edge ( self , edge ) rev = Edge ( edge . dest , edge . src ) Digraph . add_edge ( self , rev ) Node dataclass Node is a container to hold authors. Attributes: Name Type Description name str name of the author __str__ ( self ) special Returns the name as the string. Returns: Type Description str str: Name attribute of the node. Source code in scholar_network/models.py def __str__ ( self ) -> str : \"\"\"Returns the name as the string. Returns: str: Name attribute of the node. \"\"\" return self . name","title":"Models"},{"location":"api-reference/models/#models","text":"This module contains the data models for building the network graph.","title":"Models"},{"location":"api-reference/models/#src.scholar_network.models.CustomCounter","text":"Custom counter class built to emulate Counter from std lib. This class utilizes a specific use case for this program, and uses 'reflexive tuple matching' to get synonymous pairs. Parameters: Name Type Description Default lst list[tuple[str, str]] A list of author-tuple pairs. required","title":"CustomCounter"},{"location":"api-reference/models/#src.scholar_network.models.CustomCounter.__post_init__","text":"Converts author pairs into counts of unique pairs. After initialization, converts the list of tuple pairs into keys in a dictionary and increments the value by the count of the key. Also sorts the pairs so that reflexive tuples are caught. Stores the built dictionary in self.counts . Parameters: Name Type Description Default lst list A list of author-tuple pairs. required Source code in scholar_network/models.py def __post_init__ ( self , lst : list [ tuple [ str , str ]]): \"\"\"Converts author pairs into counts of unique pairs. After initialization, converts the list of tuple pairs into keys in a dictionary and increments the value by the count of the key. Also sorts the pairs so that reflexive tuples are caught. Stores the built dictionary in `self.counts`. Parameters: lst (list[tuple[str, str]]): A list of author-tuple pairs. \"\"\" result = defaultdict ( int ) for pair in lst : # by sorting we can ensure we catch the 'reflexive tuples' sorted_pair = tuple ( sorted ( pair )) result [ sorted_pair ] += 1 self . counts = result","title":"__post_init__()"},{"location":"api-reference/models/#src.scholar_network.models.CustomCounter.most_common","text":"Sorts and returns ordered tuple pairs. Parameters: Name Type Description Default limit Optional[int] Limit to return. Defaults to None. None Returns: Type Description list list[tuple[tuple[str, str], int]]: Returns most common tuple pairs. Source code in scholar_network/models.py def most_common ( self , limit : Union [ int , None ] = None ) -> list [ tuple [ tuple [ str , str ], int ]]: \"\"\"Sorts and returns ordered tuple pairs. Args: limit (Union[int, None], optional): Limit to return. Defaults to None. Returns: list[tuple[tuple[str, str], int]]: Returns most common tuple pairs. \"\"\" ordered_keys = sorted ( self . counts , key = lambda x : self . counts [ x ], reverse = True ) ordered_result : list [ tuple [ tuple [ str , str ], int ]] = [] for item in ordered_keys : ordered_result . append (( item , self . counts [ item ])) return ordered_result [: limit ] if limit else ordered_result","title":"most_common()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph","text":"Directed graph class. This class utilizes Node and Edge to store graph connections. Attributes: Name Type Description edges dict[Node, list[Node]] Connections stored as a dict of src node mapped to a list of connected nodes. Repeats allowed.","title":"Digraph"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.add_edge","text":"Adds a new edge/connection to the graph. Parameters: Name Type Description Default edge Edge Edge to add to the graph required Exceptions: Type Description ValueError Raises ValueError if either src or dest Nodes not in graph. Source code in scholar_network/models.py def add_edge ( self , edge : Edge ): \"\"\"Adds a new edge/connection to the graph. Args: edge (Edge): Edge to add to the graph Raises: ValueError: Raises ValueError if either src or dest Nodes not in graph. \"\"\" if not ( edge . src in self . edges and edge . dest in self . edges ): raise ValueError ( \"Node not in graph\" ) self . edges [ edge . src ] . append ( edge . dest )","title":"add_edge()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.add_node","text":"Adds a new node to the graph. Parameters: Name Type Description Default node Node New Node to add. required Source code in scholar_network/models.py def add_node ( self , node : Node ): \"\"\"Adds a new node to the graph. Args: node (Node): New Node to add. \"\"\" if node not in self . edges : self . edges [ node ] = [] else : pass","title":"add_node()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.children","text":"Get's Nodes that node is linked to. Parameters: Name Type Description Default node Node Node to extract children from. required Returns: Type Description list list[Node]: List of Nodes connected to the target node. Duplicates allowed. Source code in scholar_network/models.py def children ( self , node : Node ) -> list [ Node ]: \"\"\"Get's Nodes that `node` is linked to. Args: node (Node): Node to extract children from. Returns: list[Node]: List of Nodes connected to the target node. Duplicates allowed. \"\"\" return self . edges [ node ]","title":"children()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.edge_count","text":"Counts all the edges in the graph. Duplicates are counted. Returns: Type Description int int: Number of edges/connections in the graph. Source code in scholar_network/models.py def edge_count ( self ) -> int : \"\"\"Counts all the edges in the graph. Duplicates are counted. Returns: int: Number of edges/connections in the graph. \"\"\" return sum ( len ( self . children ( node )) for node in self . edges )","title":"edge_count()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.edge_rank","text":"Ranks the edges based on their weight. Ranks are calculated either for the entire graph (default) or for the specified Node. Parameters: Name Type Description Default vertex Optional[src.scholar_network.models.Node] Node to run calculation on. Defaults to None. None limit Optional[int] Limit for the number of edges returned. Defaults to None. None Returns: Type Description list list[tuple[tuple[str, str], int]]: Returns a sorted (by weight) list of edges up to the limit parameter. Source code in scholar_network/models.py def edge_rank ( self , vertex : Union [ Node , None ] = None , limit : Union [ int , None ] = None ) -> list [ tuple [ tuple [ str , str ], int ]]: \"\"\"Ranks the edges based on their weight. Ranks are calculated either for the entire graph (default) or for the specified Node. Args: vertex (Union[Node, None], optional): Node to run calculation on. Defaults to None. limit (Union[int, None], optional): Limit for the number of edges returned. Defaults to None. Returns: list[tuple[tuple[str, str], int]]: Returns a sorted (by weight) list of edges up to the limit parameter. \"\"\" if vertex : pairs = [] for partner in self . edges [ vertex ]: pairs . append (( vertex . name , partner . name )) return ( CustomCounter ( pairs ) . most_common ( limit ) if limit else CustomCounter ( pairs ) . most_common () ) return ( CustomCounter ( self . node_pairs ()) . most_common ( limit ) if limit else CustomCounter ( self . node_pairs ()) . most_common () )","title":"edge_rank()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.get_node","text":"Gets a Node from the graph based on the Node's name attribute. Parameters: Name Type Description Default name str Name of the Node to return from the graph. required Exceptions: Type Description NameError If no matching Node can be found. Returns: Type Description Node Node: The Node matching the search name. Source code in scholar_network/models.py def get_node ( self , name : str ) -> Node : \"\"\"Gets a Node from the graph based on the Node's name attribute. Args: name (str): Name of the Node to return from the graph. Raises: NameError: If no matching Node can be found. Returns: Node: The Node matching the search name. \"\"\" for n in self . edges : if n . name == name : return n raise NameError ( name )","title":"get_node()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.has_node","text":"Checks if the graph contains a given Node. Parameters: Name Type Description Default node Node Node to search the graph for. required Returns: Type Description bool bool: True if the node exists, otherwise False. Source code in scholar_network/models.py def has_node ( self , node : Node ) -> bool : \"\"\"Checks if the graph contains a given Node. Args: node (Node): Node to search the graph for. Returns: bool: True if the node exists, otherwise False. \"\"\" return node in self . edges","title":"has_node()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.node_pairs","text":"Generates pairs of nodes representing edge connections. Duplicates allowed. Returns: Type Description list list[tuple[str, str]]: List of node pairs. Source code in scholar_network/models.py def node_pairs ( self ) -> list [ tuple [ str , str ]]: \"\"\"Generates pairs of nodes representing edge connections. Duplicates allowed. Returns: list[tuple[str, str]]: List of node pairs. \"\"\" pairs = [] for src in self . edges : for dest in self . edges [ src ]: pairs . append (( src . name , dest . name )) return pairs","title":"node_pairs()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.vertex_count","text":"Counts the total number of Nodes in the graph. Returns: Type Description int int: Number of Nodes in the graph. Source code in scholar_network/models.py def vertex_count ( self ) -> int : \"\"\"Counts the total number of Nodes in the graph. Returns: int: Number of Nodes in the graph. \"\"\" return len ( self . edges )","title":"vertex_count()"},{"location":"api-reference/models/#src.scholar_network.models.Digraph.vertex_degree","text":"Calculates the number of Nodes connected to the target vertex. If no target vertex provided, calculates connected Nodes for each Node in the graph. Parameters: Name Type Description Default vertex Optional[src.scholar_network.models.Node] Target vertex to search for. Defaults to None. None Returns: Type Description Union[int, list[int]] Union[int, list[int]]: Either the degree of the target vertex or a list of the degrees of all the nodes. Source code in scholar_network/models.py def vertex_degree ( self , vertex : Union [ Node , None ] = None ) -> Union [ int , list [ int ]]: \"\"\"Calculates the number of Nodes connected to the target vertex. If no target vertex provided, calculates connected Nodes for each Node in the graph. Args: vertex (Union[Node, None], optional): Target vertex to search for. Defaults to None. Returns: Union[int, list[int]]: Either the degree of the target vertex or a list of the degrees of all the nodes. \"\"\" if vertex : return len ( self . children ( vertex )) return sorted ([ len ( self . children ( n )) for n in self . edges ])","title":"vertex_degree()"},{"location":"api-reference/models/#src.scholar_network.models.Edge","text":"Edge connects Nodes that co-occur together in the same publication. Edges are directed in a DiGraph and undirected in Graph. ^^ Both of these cases are handled by the (Di)Graph classes not the Edge itself. Attributes: Name Type Description src Node Source node for the connection. dest Node Destination node for the connection.","title":"Edge"},{"location":"api-reference/models/#src.scholar_network.models.Edge.__str__","text":"Makes the string representation an of the edge connection. Returns: Type Description str str: Connection being represented by the edge in string form. Source code in scholar_network/models.py def __str__ ( self ) -> str : \"\"\"Makes the string representation an of the edge connection. Returns: str: Connection being represented by the edge in string form. \"\"\" return f \" { self . src } -> { self . dest } \"","title":"__str__()"},{"location":"api-reference/models/#src.scholar_network.models.Graph","text":"Undirected sub-class of the Digraph.","title":"Graph"},{"location":"api-reference/models/#src.scholar_network.models.Graph.add_edge","text":"Adds both (directed) edges to the graph. Source code in scholar_network/models.py def add_edge ( self , edge : Edge ): \"\"\"Adds both (directed) edges to the graph.\"\"\" Digraph . add_edge ( self , edge ) rev = Edge ( edge . dest , edge . src ) Digraph . add_edge ( self , rev )","title":"add_edge()"},{"location":"api-reference/models/#src.scholar_network.models.Node","text":"Node is a container to hold authors. Attributes: Name Type Description name str name of the author","title":"Node"},{"location":"api-reference/models/#src.scholar_network.models.Node.__str__","text":"Returns the name as the string. Returns: Type Description str str: Name attribute of the node. Source code in scholar_network/models.py def __str__ ( self ) -> str : \"\"\"Returns the name as the string. Returns: str: Name attribute of the node. \"\"\" return self . name","title":"__str__()"},{"location":"api-reference/scraping/","text":"Scraping This module contains information on scraping data from Google Scholar. This module utilizes the selenium package to automate web scraping and stores the scraped data in 'data/scraped.json' file. It scrapes, for each author_id provided, all of the publications for that author listed on Google Scholar. For each publication, the journal title and list of authors are extracted. get_publication_data ( author_id ) Retrives data from Google Scholar. This function is the primary web-utility that opens a new selenium window to automate visiting Google Scholar and extracting data. Parameters: Name Type Description Default author_id str Google Scholar ID of the author information to extract. required Returns: Type Description list list[dict[str, str]]: A list of publication data, each dictionary containing keys for the journal_title and authors both having string keys. Source code in scholar_network/scraping.py def get_publication_data ( author_id : str ) -> list [ dict [ str , str ]]: \"\"\"Retrives data from Google Scholar. This function is the primary web-utility that opens a new selenium window to automate visiting Google Scholar and extracting data. Args: author_id (str): Google Scholar ID of the author information to extract. Returns: list[dict[str, str]]: A list of publication data, each dictionary containing keys for the `journal_title` and `authors` both having string keys. \"\"\" driver = webdriver . Safari () data = [] profile_link = f \"https://scholar.google.com/citations?user= { author_id } &hl=en&oi=ao\" driver . get ( profile_link ) pub_elements = driver . find_elements_by_css_selector ( \"a.gsc_a_at\" ) for pub in pub_elements : pub_info_link = pub . get_attribute ( \"data-href\" ) driver . get ( f \"https://scholar.google.com { pub_info_link } \" ) elements = driver . find_elements_by_class_name ( \"gsc_vcd_value\" ) if len ( elements ) > 3 : data . append ( { \"journal_title\" : elements [ 2 ] . text , \"authors\" : elements [ 0 ] . text } ) driver . back () driver . close () return data scrape_single_author ( scholar_id , scholar_name = '' ) Scrapes data from google scholar and saves into json file. Parameters: Name Type Description Default scholar_id str Google Scholar ID of the author information to extract. required scholar_name str Name of the scholar. Defaults to ''. '' Source code in scholar_network/scraping.py def scrape_single_author ( scholar_id : str , scholar_name : str = '' ): \"\"\"Scrapes data from google scholar and saves into json file. Args: scholar_id (str): Google Scholar ID of the author information to extract. scholar_name (str, optional): Name of the scholar. Defaults to ''. \"\"\" pub_data = get_publication_data ( scholar_id ) helpers . append_pub_data_to_json ( pub_data ) print ( f \"Wrote { scholar_name if scholar_name else scholar_id } to file.\" )","title":"Scraping"},{"location":"api-reference/scraping/#scraping","text":"This module contains information on scraping data from Google Scholar. This module utilizes the selenium package to automate web scraping and stores the scraped data in 'data/scraped.json' file. It scrapes, for each author_id provided, all of the publications for that author listed on Google Scholar. For each publication, the journal title and list of authors are extracted.","title":"Scraping"},{"location":"api-reference/scraping/#src.scholar_network.scraping.get_publication_data","text":"Retrives data from Google Scholar. This function is the primary web-utility that opens a new selenium window to automate visiting Google Scholar and extracting data. Parameters: Name Type Description Default author_id str Google Scholar ID of the author information to extract. required Returns: Type Description list list[dict[str, str]]: A list of publication data, each dictionary containing keys for the journal_title and authors both having string keys. Source code in scholar_network/scraping.py def get_publication_data ( author_id : str ) -> list [ dict [ str , str ]]: \"\"\"Retrives data from Google Scholar. This function is the primary web-utility that opens a new selenium window to automate visiting Google Scholar and extracting data. Args: author_id (str): Google Scholar ID of the author information to extract. Returns: list[dict[str, str]]: A list of publication data, each dictionary containing keys for the `journal_title` and `authors` both having string keys. \"\"\" driver = webdriver . Safari () data = [] profile_link = f \"https://scholar.google.com/citations?user= { author_id } &hl=en&oi=ao\" driver . get ( profile_link ) pub_elements = driver . find_elements_by_css_selector ( \"a.gsc_a_at\" ) for pub in pub_elements : pub_info_link = pub . get_attribute ( \"data-href\" ) driver . get ( f \"https://scholar.google.com { pub_info_link } \" ) elements = driver . find_elements_by_class_name ( \"gsc_vcd_value\" ) if len ( elements ) > 3 : data . append ( { \"journal_title\" : elements [ 2 ] . text , \"authors\" : elements [ 0 ] . text } ) driver . back () driver . close () return data","title":"get_publication_data()"},{"location":"api-reference/scraping/#src.scholar_network.scraping.scrape_single_author","text":"Scrapes data from google scholar and saves into json file. Parameters: Name Type Description Default scholar_id str Google Scholar ID of the author information to extract. required scholar_name str Name of the scholar. Defaults to ''. '' Source code in scholar_network/scraping.py def scrape_single_author ( scholar_id : str , scholar_name : str = '' ): \"\"\"Scrapes data from google scholar and saves into json file. Args: scholar_id (str): Google Scholar ID of the author information to extract. scholar_name (str, optional): Name of the scholar. Defaults to ''. \"\"\" pub_data = get_publication_data ( scholar_id ) helpers . append_pub_data_to_json ( pub_data ) print ( f \"Wrote { scholar_name if scholar_name else scholar_id } to file.\" )","title":"scrape_single_author()"}]}